import { LexicalEditor } from "lexical";
import { EditorConfig } from "lexical/LexicalEditor";
import React, { ElementType } from "react";
import { BeautifulMentionComponentProps } from "./BeautifulMentionsPluginProps";
import { BeautifulMentionNode, SerializedBeautifulMentionNode } from "./MentionNode";
export declare let CustomBeautifulMentionNode: ReturnType<typeof generateClass>;
/**
 * Instead of using the default `BeautifulMentionNode` class, you can
 * extend it and use the mention component of your choice.
 */
export declare function createBeautifulMentionNode(mentionComponent: ElementType<BeautifulMentionComponentProps>): ({
    new (trigger: string, value: string, data?: {
        [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
    } | undefined, key?: string | undefined): {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): React.ElementType<BeautifulMentionComponentProps<{}>> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    getType(): string;
    clone(node: {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): React.ElementType<BeautifulMentionComponentProps<{}>> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    }): {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): React.ElementType<BeautifulMentionComponentProps<{}>> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importJSON(serializedNode: SerializedBeautifulMentionNode): {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): React.ElementType<BeautifulMentionComponentProps<{}>> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importDOM(): {
        span: (domNode: HTMLElement) => {
            conversion: (domNode: HTMLElement) => import("lexical").DOMConversionOutput | null;
            priority: number;
        } | null;
    };
    transform(): ((node: import("lexical").LexicalNode) => void) | null;
} | {
    replace: typeof BeautifulMentionNode;
    with: (node: BeautifulMentionNode) => {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): React.ElementType<BeautifulMentionComponentProps<{}>> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
})[];
declare function generateClass(mentionComponent: ElementType<BeautifulMentionComponentProps>): {
    new (trigger: string, value: string, data?: {
        [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
    } | undefined, key?: string | undefined): {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    getType(): string;
    clone(node: {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    }): {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importJSON(serializedNode: SerializedBeautifulMentionNode): {
        [x: string]: any;
        exportJSON(): SerializedBeautifulMentionNode;
        component(): ElementType<BeautifulMentionComponentProps> | null;
        decorate(editor: LexicalEditor, config: EditorConfig): React.JSX.Element;
        __trigger: string;
        __value: string;
        __data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        exportDOM(): {
            element: HTMLSpanElement;
        };
        createDOM(): HTMLSpanElement;
        getTextContent(): string;
        updateDOM(): boolean;
        getTrigger(): string;
        getValue(): string;
        setValue(value: string): void;
        getData(): {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined;
        setData(data?: {
            [p: string]: import("./BeautifulMentionsPluginProps").BeautifulMentionsItemData;
        } | undefined): void;
        isIsolated(): boolean;
        isInline(): boolean;
        isKeyboardSelectable(): boolean;
        __type: string;
        __key: string;
        __parent: string | null;
        __prev: string | null;
        __next: string | null;
        getType(): string;
        isAttached(): boolean;
        isSelected(selection?: import("lexical").RangeSelection | import("lexical").NodeSelection | import("lexical").GridSelection | null | undefined): boolean;
        getKey(): string;
        getIndexWithinParent(): number;
        getParent<T extends import("lexical").ElementNode>(): T | null;
        getParentOrThrow<T_1 extends import("lexical").ElementNode>(): T_1;
        getTopLevelElement(): import("lexical").ElementNode | any | null;
        getTopLevelElementOrThrow(): import("lexical").ElementNode | any;
        getParents(): import("lexical").ElementNode[];
        getParentKeys(): string[];
        getPreviousSibling<T_2 extends import("lexical").LexicalNode>(): T_2 | null;
        getPreviousSiblings<T_3 extends import("lexical").LexicalNode>(): T_3[];
        getNextSibling<T_4 extends import("lexical").LexicalNode>(): T_4 | null;
        getNextSiblings<T_5 extends import("lexical").LexicalNode>(): T_5[];
        getCommonAncestor<T_6 extends import("lexical").ElementNode = import("lexical").ElementNode>(node: import("lexical").LexicalNode): T_6 | null;
        is(object: import("lexical").LexicalNode | null | undefined): boolean;
        isBefore(targetNode: import("lexical").LexicalNode): boolean;
        isParentOf(targetNode: import("lexical").LexicalNode): boolean;
        getNodesBetween(targetNode: import("lexical").LexicalNode): import("lexical").LexicalNode[];
        isDirty(): boolean;
        getLatest(): any;
        getWritable(): any;
        getTextContentSize(): number;
        remove(preserveEmptyParent?: boolean | undefined): void;
        replace<N extends import("lexical").LexicalNode>(replaceWith: N, includeChildren?: boolean | undefined): N;
        insertAfter(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        insertBefore(nodeToInsert: import("lexical").LexicalNode, restoreSelection?: boolean | undefined): import("lexical").LexicalNode;
        isParentRequired(): boolean;
        createParentElementNode(): import("lexical").ElementNode;
        selectPrevious(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        selectNext(anchorOffset?: number | undefined, focusOffset?: number | undefined): import("lexical").RangeSelection;
        markDirty(): void;
    };
    importDOM(): {
        span: (domNode: HTMLElement) => {
            conversion: (domNode: HTMLElement) => import("lexical").DOMConversionOutput | null;
            priority: number;
        } | null;
    };
    transform(): ((node: import("lexical").LexicalNode) => void) | null;
};
export {};
